
## Архитектура CLI

Описание архитектуры, согласно [схеме](https://drive.google.com/file/d/1QHP-Ts4yUI9QVlnk7xC-mb8wQMpIApua/view?usp=sharing).

### Модель исполнения пайпов

Есть следующие возможности для исполнения команд в пайпах:

1. Исполнять команды последовательно. В таком случае придется подумать про некоторые асинхронные действия, а именно про обработку сигналов для реализации graceful shutdown. Это может быть сделано с использованием флага, который будет проверяться перед каждым действием определенной команды.

2. Исполнять команды на пуле потоков, или создавать для каждой команды свой процесс. Исполнение будет происходить со степенью параллельности `MAX_PARRALLEL_JOBS`, задаваемой пользователем через аргумент командной строки, или переменную среды родительского shell. Для этого пункта надо реализовать (или использовать готовые):
    - `Task`, позволяющий следить за своим окончанием через условную переменную.
    - `TaskExecutor`, позволяющий ставить `Task`и в очередь на исполнение.
    - Создать пул потоков/процессов воркеров на стадии инициализации (либо же создавать потоки/процессы каждый раз заново).
    - `Context`, позволяющий отменять запущенные задачи, может быть реализован через атомарную переменную.

Этот способ довольно трудозатратный и если хочется исполнять команды параллельно, и выбранный для реализации язык предоставляет корутиный рантайм (например, Go), или есть готовое решение (например, tokio в Rust), то рекомендуется использовать следующий способ.

3. Исполнять команды в корутинах на пуле потоков такого же размера, как в предыдущем пункте. Это позволяет с `MAX_PARALLEL_JOBS=1` исполнять несколько команд одновременно, если они, например, много читают из файлов.

Дальнейшее описание предполагает выбор пункта 3, так как он является наиболее легко реализуемым и расшрияемым, а также большинство современных языков предоставляют необходимый функционал.

### Инициализация

Выполняется при старте shell, на этом шаге происходит:
- Создание Env.
- Создание контекста `sigCtx` и выставление обработчика сигналов для graceful shutdown (SIGINT, SIGTERM). Каждый обработчик отменяет контекст `sigCtx`.
- Запуск shell loop.

### Shell loop

Бесконечный цикл, читает и исполняет команды. на старте создает буффер для чтения входной строки `inbuf` фиксированного размера (конфигурируемый параметр `IN_BUF_SIZE`).

Каждая итерация внешнего цикла устроена следующим образом:

- Создать экземпляр `parser = Parser(inbuf)`.

- Внутренний цикл:
  - Прочитать строчку из stdin до следующего символа перевода строки в  буффер `inbuf`.
  - Позвать `parser.Parse`.
    - если он вернул `Some([]Command)`, то запомнить список команд в `commands` и выйти.
    - если он вернул ошибку, то вывести ее и завершить работу.
  - Перейти к следующей итерации внутреннего цикла.

- Создать `executor = Executor(commands)`.

- Позвать `executor.Run()`, в случае ошибки вывести ее и выйти, иначе перейти к следующей итерации внешнего цикла.

### Env

Конкурентный хешмап, хранящий отображение из строк в строки.

### Chan

Структура для коммуникации двух соседних команд в пайпе между собой.

Реализуется при помощи многопоточной `spsc` очереди из байтов. Позволяет записать слайс байтов, прочитать
хранящиеся байты. Позволяет закрыть себя. Если происходит запись в закрытый канал, то пишущему возвращается
ошибка, аналогично с чтением из закрытого канала. Если при записи достигается размер буффера, то пишущая
корутина блокируется до тех пор, пока читатель не прочитает значения из канала, за счет этого ограничивается
объем используемой памяти.

### Command interface

`Interface command` - интерфейс, который реализуют все команды. Имеет единственный метод `Run(ctx, in chan, out chan)`. В первый аргумент метода `Run`, `Executor` передает контекст `ctx`, во второй `in` - входной канал (выходной канал предыдущей команды), в третий `out` - выходной канал (входной канал следующей команды).
Поскольку было решено использовать корутины, то реализация метода Run может асинхронно читать/писать в неблокирующем режиме, а так же звать `yield()`, если он чего-то ожидает. В реализации могут быть в нужных местах быть выставлены cancelation point'ы, и таким образом может быть реализовано принудительное завершение команды. Например, имеет смысл проверять, не была ли данная корутина отменена, после каждого вызова `yield()`. В принципе, для этого не обязательно использовать контекст, это может быть реализовано через API соответствующих корутин.

#### Cat

`CatCommand`. Если не было передано ни одного аргумента, то читает из `in`, и пишет прочитанное в `out`. Прерывается, если в какой-то момент обнаруживает, что входной/выходной канал закрыт.
Иначе если было передано одно или более имен файлов, сразу закрывает `in`, после чего по очереди читает содержимое файлов и пишет его в `out`. Прерывается, если в какой-то момент обнаруживает, что выходной канал закрыт.

#### Wc

`WcCommand`. Если не было передано ни одного аргумента, то читает из `in`, считает статистики. Прерывается, если в какой-то момент обнаруживает, что входной/выходной канал закрыт.
Иначе если было передано одно или более имен файлов, сразу закрывает `in`, после чего по очереди читает содержимое файлов и считает статистки. Прерывается, если в какой-то момент обнаруживает, что выходной канал закрыт. В конце пишет посчитанную статистику в `out`.

#### Echo

`EchoCommand`. Закрывает входной канал. Пишет аргументы в `out`.

#### Pwd

`PwdCommand`. Закрывает входной канал. Достает путь до текущей директории из Env. Пишет этот путь в `out`.

#### Exit

`ExitCommand`. Закрывает оба канала - входной и выходной.

#### Process

`ProcessCommand`. Запускает переданный исполняемый файл в отдельном процессе, передает туда оставшиеся аргументы. Перенаправляет поток из `in` в stdin процесса. Перенаправляет вывод из stdout процесса в `out` канал.

#### SetEnv

`SetEnv`. Закрывает оба канала - входной и выходной. Присваивает значение в переменную окружения.

### Syntax analyzer

Синтаксический анализатор производит анализ входной строки, создавая из нее список имплементаций интерфейса
`Command`, которые должны быть исполнены.

Для того чтобы описать работу анализатора необходимо формализовать требования по задаче. Мы это сделаем,
используя контекстно-свободную грамматику. Далее идет описание этой грамматики, в которой терминалы отличаются
от нетерминалов регистром: для терминалов используется только большие буквы.

```
cmdPiped ::= cmd r

r ::= EPS |
      PIPE cmdPiped

cmd ::= catCMD  |
        echoCMD |
        wcCMD   |
        pwdCMD  |
        exitCMD |
        procCMD |
        SETCMD(src, dst)

catCMD  ::= PATH("cat") args
echoCMD ::= PATH("echo)
wcCMD   ::= PATH("wc") args
pwdCMD  ::= PATH("pwd")
exitCMD ::= PATH("exit")
procCMD ::= PATH(_) args

args ::= EPS |
         PATH(_) args
```

- У терминала `PATH` есть аттрибут: непосредственная строчка путь. Аттрибут представляет из себя любую строку.

- У терминала `SETCMD` есть два атрибута: `src` и `dst`, src удовлетворяет регулярному выражению:
```
[_a-zA-Z][_a-zA-Z0-9]{0,30}
```
dst - любая строчка.

В построенной грамматике уже выполнены все замены и рассматриваются конкретные строчки.

Далее рассмотрим лексер, который позволяет разобрать общую структуру интерпретируемого
выражения, выполнить подстановки, разбить строчки на нетерминалы и передать их в парсер для формирования
списка команд.

#### Lexer
Лексер разбирает входную команду. При этом непосредственно интерпретируемые инструкции (`|`, `=`, `'`, `"`,
`\`) нельзя получить из подстановки, то есть после осуществления подстановки, в подставленной строке не ищутся вхождения интерпретируемых команд, как, например, в bash:

```sh
$ echo "x" | cat
x
$ y="|cat"
$ echo "x" $y
x |cat
```

Это исключает возможность управления структурой команды из неизвестных строк, что может предовратить code
injection.

В целом, вся работа лексера задается конечным автоматом, то есть регулярным выражением. Опишем этот автомат чуть подробнее.

Следующие действия происходят при вызове `next`.
- Если текущий символ это пробел, то pos сдвигается на 1 и мы продолжаем, ничего не возвращая.
- Если текущий символ это символ `|`, то он сдвигает pos на 1 и возвращает `PIPE`.
- Иначе сдвигает pos, пока не встретит неэкранированный `|` или пробел, выписывая символы и учитывая
  модификаторы: `', ", \`:
    - При встрече модификатора `\`,
      следующий символ явно дописывается в конец текущей строки (будь то `|` или `=`), то есть экранируется.
    - При встрече модификатора `"`, лексер запоминает, что все читаемые символы (кроме `"`, `$`, которые надо
    экранировать явно) должны быть экранированы, пока он не встретит неэкранированный
    `"`.
    - При встрече модификатора `'`, лексер запоминает, что все читаемые символы (кроме `'`, который теперь
    надо экранировать явно) должны быть экранированы, пока не встретит неэкранированный `'`.
    - При встрече неэкранированного `$`, лексер жадно читает следующие символы, пока они не выходят за рамки
    регулярного выражения для `src`, и берет значение прочитанного ключа из `Env`,
    и дописывает его к текущей строке.
    - Если лексер встречает неэкранированное `=`, то он проверяет, что строка, которая была выписана до этого
    не содержала управляющих символов (т.е "abc"="x", a'b'=4 запрещено, необходимо явно указывать левый
    операнд abc="x", b=4). Если это так, то он запоминает, что в текущий момент мы разбираем нетерминал
    `SETCMD`, и что оставшийся суффикс должен быть рассмотрен как `dst`.
- В конце у нас получается некоторая строка `s`, или же готовый терминал `SETCMD`. Если это `SETCMD`, то лексер
возвращает его, иначе возвращает `PATH(s)`.
- Если мы достигли конца строки, то надо проверить, что текущее состояние это не "читаем `"`, `'` строку". Если это так, то надо вернуть вернуть специальное значение и оповестить парсер о том, что ему необходимо
запросить у пользователя новую часть строки.

Можно явно выписать этот автомат и написать реализацию лексера как разбор автомата (или сгенерировать код). В такой автомат мы можем в будущем добавлять новые модификаторы ввода.

#### Parser

Принимает от лексера очередной нетерминал, разбирая выражение согласно вышеописанной грамматике.
Предлагается использовать простой `LL(1)` парсер. Опишем один случай, а остальные реализуются аналогично.

Допустим, надо распарсить нетерминал: `catCMD`. Парсер зовет `next` на лексере, проверяет, что возвращенный
результат это `PATH("cat")`, дальше вызывает `parse_args()`. `parse_args()` в свою очередь читает зовет
`next`, пока ему возвращаются `PATH(...)`. Как только возвращается `PIPE`, то метод возвращается.
Может быть удобно реализовать метод `peek` у лексера, чтобы не потреблять следующий нетерминал, а иметь
возможность просто его проверить.

Далее, `parse_cat()` проверяет, что размер распаршенных аргументов это 0 (если нет, то возвращает ошибку).
Создает экземпляр `CatCMD` и кладет его в конец поддерживаемого `cmdList`.
Как только заканчивается ввод и лексер удовлетворен (последний пункт в лексере), то список команд построен, он
возвращается и исполняется при помощи `Executor`.

Самая корневая функция парсинга `parse_cmd()` должна проверять, какой `PATH` будет следующим при помощи `peek`
и исходя из этого выбирать, какую функцию вызвать дальше.

### Executor

Executor принимает список абстрактных команд, которые надо исполнить. На старте он создает `N+1` каналов `Chan` и ставит в очередь на исполнение (которая уже абстрагирует в себе максимальный возможный паралеллизм) команды, передавая им созданные каналы, а также общий контекст, который может быть отменен одной из команд при
ошибке.

Получив хендлеры запущенных команд, он дожидается завершения команд, либо ошибки одной из команд, о которой
они могут сообщить через общий контекст. Если это происходит, то он завершает остальные команды через этот же
контекст и выводит ошибку на экран.

Также, он следит за контекстом `sigCtx` и в случае получения процессом сигнала на завершение, он отменит
все запущенные команды.
