
## Архитектура CLI

Описание архитектуры, согласно [схеме](https://drive.google.com/file/d/1QHP-Ts4yUI9QVlnk7xC-mb8wQMpIApua/view?usp=sharing).

### Модель исполнения пайпов

Есть следующие возможности для исполнения команд в пайпах:

1. Исполнять команды последовательно. В таком случае придется подумать про некоторые асинхронные действия, а именно про обработку сигналов для реализации graceful shutdown. Это может быть сделано с использованием флага, который будет проверяться перед каждым действием определенной команды.

2. Исполнять команды на пуле потоков, или создавать для каждой команды свой процесс. Исполнение будет происходить со степенью параллельности `MAX_PARRALLEL_JOBS`, задаваемой пользователем через аргумент командной строки, или переменную среды родительского shell. Для этого пункта надо реализовать (или использовать готовые):
    - `Task`, позволяющий следить за своим окончанием через условную переменную.
    - `TaskExecutor`, позволяющий ставить `Task`и в очередь на исполнение.
    - Создать пул потоков/процессов воркеров на стадии инициализации (либо же создавать потоки/процессы каждый раз заново).
    - `Context`, позволяющий отменять запущенные задачи, может быть реализован через атомарную переменную.

Этот способ довольно трудозатратный и если хочется исполнять команды параллельно, и выбранный для реализации язык предоставляет корутиный рантайм (например, Go), или есть готовое решение (например, tokio в Rust), то рекомендуется использовать следующий способ.

3. Исполнять команды в корутинах на пуле потоков такого же размера, как в предыдущем пункте. Это позволяет с `MAX_PARALLEL_JOBS=1` исполнять несколько команд одновременно, если они, например, много читают из файлов.

Дальнейшее описание предполагает выбор пункта 3, так как он является наиболее легко реализуемым и расшрияемым, а также большинство современных языков предоставляют необходимый функционал.

### Инициализация

Выполняется при старте shell, на этом шаге происходит:
- Создание Env.
- Создание контекста `sigCtx` и выставление обработчика сигналов для graceful shutdown (SIGINT, SIGTERM). Каждый обработчик отменяет контекст `sigCtx`.
- Запуск shell loop.

### Shell loop

Бесконечный цикл, читает и исполняет команды. на старте создает буффер для чтения входной строки `inbuf` фиксированного размера (конфигурируемый параметр `IN_BUF_SIZE`).

Каждая итерация внешнего цикла устроена следующим образом:

- Создать экземпляр `parser = Parser(inbuf)`.

- Внутренний цикл:
  - Прочитать строчку из stdin до следующего символа перевода строки в  буффер `inbuf`.
  - Позвать `parser.Parse`.
    - если он вернул `Some([]Command)`, то запомнить список команд в `commands` и выйти.
    - если он вернул ошибку, то вывести ее и завершить работу.
  - Перейти к следующей итерации внутреннего цикла.

- Создать `executor = Executor(commands)`.

- Позвать `executor.Run()`, в случае ошибки вывести ее и выйти, иначе перейти к следующей итерации внешнего цикла.

### Env

### Chan

### Command interface

#### Cat

#### Wc

#### Echo

#### Pwd

#### Exit

#### Process

#### SetEnv

### Syntax analyzer

Синтаксический анализатор производит анализ входной строки, создавая из нее список имплементаций интерфейса
`Command`, которые должны быть исполнены.

Для того чтобы описать работу анализатора необходимо формализовать требования по задаче. Мы это сделаем,
используя контекстно-свободную грамматику. Далее идет описание этой грамматики, в которой терминалы отличаются
от нетерминалов регистром: для терминалов используется только большие буквы.

```
cmdPiped ::= cmd r

r ::= EPS |
      PIPE cmdPiped

cmd ::= catCMD  |
        echoCMD |
        wcCMD   |
        pwdCMD  |
        exitCMD |
        procCMD |
        SETCMD(src, dst)

catCMD  ::= PATH("cat") args
echoCMD ::= PATH("echo)
wcCMD   ::= PATH("wc") args
pwdCMD  ::= PATH("pwd")
exitCMD ::= PATH("exit")
procCMD ::= PATH(_) args

args ::= EPS |
         PATH(_) args
```

- У терминала `PATH` есть аттрибут: непосредственная строчка путь. Аттрибут представляет из себя любую строку.

- У терминала `SETCMD` есть два атрибута: `src` и `dst`, src удовлетворяет регулярному выражению:
```
[_a-zA-Z][_a-zA-Z0-9]{0,30}
```
dst - любая строчка.

В построенной грамматике уже выполнены все замены и рассматриваются конкретные строчки.

Далее рассмотрим лексер, который позволяет разобрать общую структуру интерпретируемого
выражения, выполнить подстановки, разбить строчки на нетерминалы и передать их в парсер для формирования
списка команд.

#### Lexer
Лексер разбирает входную команду. При этом непосредственно интерпретируемые инструкции (`|`, `=`, `'`, `"`,
`\`) нельзя получить из подстановки, то есть после осуществления подстановки, в подставленной строке не ищутся вхождения интерпретируемых команд, как, например, в bash:

```sh
$ echo "x" | cat
x
$ y="|cat"
$ echo "x" $y
x |cat
```

Это исключает возможность управления структурой команды из неизвестных строк, что может предовратить code
injection.

В целом, вся работа лексера задается конечным автоматом, то есть регулярным выражением. Опишем этот автомат чуть подробнее.

Следующие действия происходят при вызове `next`.
- Если текущий символ это пробел, то pos сдвигается на 1 и мы продолжаем, ничего не возвращая.
- Если текущий символ это символ `|`, то он сдвигает pos на 1 и возвращает `PIPE`.
- Иначе сдвигает pos, пока не встретит неэкранированный `|` или пробел, выписывая символы и учитывая
  модификаторы: `', ", \`:
    - При встрече модификатора `\`,
      следующий символ явно дописывается в конец текущей строки (будь то `|` или `=`), то есть экранируется.
    - При встрече модификатора `"`, лексер запоминает, что все читаемые символы (кроме `"`, `$`, которые надо
    экранировать явно) должны быть экранированы, пока он не встретит неэкранированный
    `"`.
    - При встрече модификатора `'`, лексер запоминает, что все читаемые символы (кроме `'`, который теперь
    надо экранировать явно) должны быть экранированы, пока не встретит неэкранированный `'`.
    - При встрече неэкранированного `$`, лексер жадно читает следующие символы, пока они не выходят за рамки
    регулярного выражения для `src`, и берет значение прочитанного ключа из `Env`,
    и дописывает его к текущей строке.
    - Если лексер встречает неэкранированное `=`, то он проверяет, что строка, которая была выписана до этого
    не содержала управляющих символов (т.е "abc"="x", a'b'=4 запрещено, необходимо явно указывать левый
    операнд abc="x", b=4). Если это так, то он запоминает, что в текущий момент мы разбираем нетерминал
    `SETCMD`, и что оставшийся суффикс должен быть рассмотрен как `dst`.
- В конце у нас получается некоторая строка `s`, или же готовый терминал `SETCMD`. Если это `SETCMD`, то лексер
возвращает его, иначе возвращает `PATH(s)`.
- Если мы достигли конца строки, то надо проверить, что текущее состояние это не "читаем `"`, `'` строку". Если это так, то надо вернуть вернуть специальное значение и оповестить парсер о том, что ему необходимо
запросить у пользователя новую часть строки.

Можно явно выписать этот автомат и написать реализацию лексера как разбор автомата (или сгенерировать код). В такой автомат мы можем в будущем добавлять новые модификаторы ввода.

#### Parser

Принимает от лексера очередной нетерминал, разбирая выражение согласно вышеописанной грамматике.
Предлагается использовать простой `LL(1)` парсер. Опишем один случай, а остальные реализуются аналогично.

Допустим, надо распарсить нетерминал: `catCMD`. Парсер зовет `next` на лексере, проверяет, что возвращенный
результат это `PATH("cat")`, дальше вызывает `parse_args()`. `parse_args()` в свою очередь читает зовет
`next`, пока ему возвращаются `PATH(...)`. Как только возвращается `PIPE`, то метод возвращается.
Может быть удобно реализовать метод `peek` у лексера, чтобы не потреблять следующий нетерминал, а иметь
возможность просто его проверить.

Далее, `parse_cat()` проверяет, что размер распаршенных аргументов это 0 (если нет, то возвращает ошибку).
Создает экземпляр `CatCMD` и кладет его в конец поддерживаемого `cmdList`.
Как только заканчивается ввод и лексер удовлетворен (последний пункт в лексере), то список команд построен, он
возвращается и исполняется при помощи `Executor`.

Самая корневая функция парсинга `parse_cmd()` должна проверять, какой `PATH` будет следующим при помощи `peek`
и исходя из этого выбирать, какую функцию вызвать дальше.

### Executor

Executor принимает список абстрактных команд, которые надо исполнить. На старте он создает `N+1` каналов `Chan` и ставит в очередь на исполнение (которая уже абстрагирует в себе максимальный возможный паралеллизм) команды, передавая им созданные каналы, а также общий контекст, который может быть отменен одной из команд при
ошибке.

Получив хендлеры запущенных команд, он дожидается завершения команд, либо ошибки одной из команд, о которой
они могут сообщить через общий контекст. Если это происходит, то он завершает остальные команды через этот же
контекст и выводит ошибку на экран.

Также, он следит за контекстом `sigCtx` и в случае получения процессом сигнала на завершение, он отменит
все запущенные команды.
