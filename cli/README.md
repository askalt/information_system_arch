
## Архитектура CLI

Описание архитектуры, согласно [схеме](https://app.diagrams.net/?src=about#G1QHP-Ts4yUI9QVlnk7xC-mb8wQMpIApua#%7B%22pageId%22%3A%22pOMVV1m6bS3iOVTog2dv%22%7D).

### Модель исполнения пайпов

Есть следующие возможности для исполнения команд в пайпах:

1. Исполнять команды последовательно. В таком случае придется подумать про некоторые асинхронные действия, а именно про обработку сигналов для реализации graceful shutdown. Это может быть сделано с использованием флага, который будет проверяться перед каждым действием определенной команды.

2. Исполнять команды на пуле потоков, или создавать для каждой команды свой процесс. Исполнение будет происходить со степенью параллельности `MAX_PARRALLEL_JOBS`, задаваемой пользователем через аргумент командной строки, или переменную среды родительского shell. Для этого пункта надо реализовать (или использовать готовые):
    - `Task`, позволяющий следить за своим окончанием через условную переменную.
    - `TaskExecutor`, позволяющий ставить `Task`и в очередь на исполнение.
    - Создать пул потоков/процессов воркеров на стадии инициализации (либо же создавать потоки/процессы каждый раз заново).
    - `Context`, позволяющий отменять запущенные задачи, может быть реализован через атомарную переменную.

Этот способ довольно трудозатратный и если хочется исполнять команды параллельно, и выбранный для реализации язык предоставляет корутиный рантайм (например, Go), или есть готовое решение (например, tokio в Rust), то рекомендуется использовать следующий способ.

3. Исполнять команды в корутинах на пуле потоков такого же размера, как в предыдущем пункте. Это позволяет с `MAX_PARALLEL_JOBS=1` исполнять несколько команд одновременно, если они, например, много читают из файлов.

Дальнейшее описание предполагает выбор пункта 3, так как он является наиболее легко реализуемым и расшрияемым, а также большинство современных языков предоставляют необходимый функционал.

### Инициализация

Выполняется при старте shell, на этом шаге происходит:
- Создание Env.
- Создание контекста `sigCtx` и выставление обработчика сигналов для graceful shutdown (SIGINT, SIGTERM). Каждый обработчик отменяет контекст `sigCtx`.
- Запуск shell loop.

### Shell loop

Бесконечный цикл, читает и исполняет команды. на старте создает буффер для чтения входной строки `inbuf` фиксированного размера (конфигурируемый параметр `IN_BUF_SIZE`).

Каждая итерация внешнего цикла устроена следующим образом:

- Создать экземпляр `parser = Parser(inbuf)`.

- Внутренний цикл:
  - Прочитать строчку из stdin до следующего символа перевода строки в  буффер `inbuf`.
  - Позвать `parser.Parse`.
    - если он вернул `Some([]Command)`, то запомнить список команд в `commands` и выйти.
    - если он вернул ошибку, то вывести ее и завершить работу.
  - Перейти к следующей итерации внутреннего цикла.

- Создать `executor = Executor(commands)`.

- Позвать `executor.Run()`, в случае ошибки вывести ее и выйти, иначе перейти к следующей итерации внешнего цикла.

### Env

### Chan

### Command interface

#### Cat

#### Wc

#### Echo

#### Pwd

#### Exit

#### Process

#### SetEnv

### Executor

### Syntax analyzer

#### Lexer

#### Parser
